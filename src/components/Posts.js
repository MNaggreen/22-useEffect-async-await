/* оба этих проекта (21 и 22) работаеют одинаково */

import { useEffect, useState } from 'react'
import Post from './Post'

const API_URL = 'https://jsonplaceholder.typicode.com/posts'
/* просто переменная */

function Posts() {
  const [posts, setPosts] = useState([])
  /* изначальное значение пустой массив */

  const [error, setError] = useState('')
  const [isLoading, setIsLoading] = useState(true)

  /*  напрямую async нельзя использовать в useEffect сначала создать стрелочную функцию и внутри это функции сделать еще одну фукнцию с пометкой
    async и далее мы ей вызываем */
  useEffect(() => {
    /* обязательно дабавляем ключевое слово async перед скобками нашей call back функции
    const res = await fetch(API_URL)
       задаем переменной резельтат полученный с сервера
    const posts = await res.json()
       принимаем и конвертируем в json наш результат
    setPosts(Posts)
       просто передаем в нашу перменную с помощью UseState список постов */

    /* const fetchData = async () => { можно также использовать тут стрелочную функцию */
    ;(async function () /* fetchData()*/ {
      /* передаем функции еще одну функцию чтобы async корректно работал */
      try {
        const res = await fetch(API_URL)
        const posts = await res.json()
        setPosts(posts)
      } catch (error) {
        setError(error.message)
        /* передаем значение нашей ошибки в переменную */
      }
      setIsLoading(false)
    })()
    /* передаем данное значение так как загрузка всех данных завершена */

    /* fetchData() */
    /* мы убрали имя функции и обернули её в скобки что позволило нам сразу её изменять
    т.е. function (тут будет код функции)(тут будет пустое поле сразу вызов) */
    /* вызываем сразу функцию это называется IIFE imidatly invoked fucntion expression*/
  }, [])
  /* массив зависимости отсавляем пустой [] */

  if (error) {
    return <h1>Error: {error}</h1>
  }
  /* если строка ошибки не пустая то код покажет ошибку */

  return (
    <>
      {/*  фрагмент реакт */}
      <h1>Posts</h1>
      <hr />
      {isLoading ? (
        /* это тернарный оператор если isLoading равно True то мы выводим код ниже ксли нет томы выводим посты, кстати isLoading выводится прямо ниже заголовка а сам заголовок появляется сразу */ <h1>
          Loading...
        </h1>
      ) : (
        posts.map(
          (post) => <Post key={post.id} {...post} />
          /* здесь мы передаем отдельно id как ключ, а также с помощью spread operator создаем обьект с несколькими элементами и передаем его в Post.js */
        )
      )}
      {/* здесь мы передаем отдельно id как ключ, а также с помощью spread
      operator создаем обьект с несколькими элементами и передаем его в Post.js */}
    </>
  )
}

export default Posts

/* данная функци вызовется два раза при запуске приложения и при рендеринге массива так как в списке зависимостей у нас пустой массив */

/* useEffect(() => {
    fetch(API_URL) сюда мы вставляем переменную
      .then((res) =>
        res.json())  */
/* если ответ от сервера успешный мы получим в res json */
/* .then((posts) => */
/* posts здесь и выше это разные переменные которые просто совпали имененем, но после вызова функции setPosts у обоих будет одиноковое значение */

/*   setPosts(posts)
      ) */
/* .catch(
        (error) =>
          setError(
            error.message))  */
/* при возникновении ошибки функция setError изменит переменную error */
/* при возникновении ошибки в консоле выведеся ошибка */
/* .finally(() =>
        setIsLoading(false))  */
/* вызовется в любом случае когда загрузка будет окончена успешно или же с ошибкой*/
/* }, [])  */

/* console.log(posts) */
/* if (isLoading) { */
/* если строка isLoading равна true, то код покажет данное сообщение */
/* return ( */
/* { */
/* <h1>Loading...</h1> */
/* } */
/* )  также можно сэмулировать медленный интенрнет чтобы увидеть сообщение */
/*  } */
